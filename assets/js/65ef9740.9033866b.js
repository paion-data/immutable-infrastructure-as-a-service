"use strict";(self.webpackChunkhashicorp_aws=self.webpackChunkhashicorp_aws||[]).push([[6747],{9481:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var t=s(3860),a=s(5639);const r={slug:"openssl-encrypt",title:"Using OpenSSL to encrypt messages and files on Linux",authors:["jiaqi"],tags:["Security"]},c=void 0,i={permalink:"/blog/openssl-encrypt",editUrl:"https://github.com/QubitPi/hashicorp-aws/tree/master/docs/blog/2023-11-23-openssl-encrypt.md",source:"@site/blog/2023-11-23-openssl-encrypt.md",title:"Using OpenSSL to encrypt messages and files on Linux",description:"OpenSSL is a powerful cryptography toolkit. Many of us have already used OpenSSL for creating RSA Private Keys or CSR",date:"2023-11-23T00:00:00.000Z",formattedDate:"November 23, 2023",tags:[{label:"Security",permalink:"/blog/tags/security"}],readingTime:4.765,hasTruncateMarker:!0,authors:[{name:"Jiaqi Liu",title:"Maintainer of hashicorp-aws",url:"https://github.com/QubitPi",imageURL:"https://avatars.githubusercontent.com/u/16126939?v=4",key:"jiaqi"}],frontMatter:{slug:"openssl-encrypt",title:"Using OpenSSL to encrypt messages and files on Linux",authors:["jiaqi"],tags:["Security"]},unlisted:!1,prevItem:{title:"Using a GitHub Action Matrix to Define Variations for Each Job",permalink:"/blog/github-matrix"},nextItem:{title:"Build and Push Docker Images through GitHub Action",permalink:"/blog/dockerhub-github-actions"}},o={authorsImageUrls:[void 0]},l=[{value:"Encrypt and Decrypt Messages",id:"encrypt-and-decrypt-messages",level:2},{value:"Encrypt and Decrypt File",id:"encrypt-and-decrypt-file",level:2},{value:"Encrypt and Decrypt Directory",id:"encrypt-and-decrypt-directory",level:2},{value:"Using Public and Private keys",id:"using-public-and-private-keys",level:2}];function p(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"OpenSSL is a powerful cryptography toolkit. Many of us have already used OpenSSL for creating RSA Private Keys or CSR\n(Certificate Signing Request). However, did you know that we can use OpenSSL to benchmark our computer speed or that we\ncan also encrypt files or messages? This post will provide you with some simple to follow tips on how to encrypt\nmessages and files using OpenSSL."}),"\n",(0,t.jsx)(n.h2,{id:"encrypt-and-decrypt-messages",children:"Encrypt and Decrypt Messages"}),"\n",(0,t.jsx)(n.p,{children:'First we can start by encrypting simple messages. The following linux command will encrypt a message "Welcome to\nLinuxCareer.com" using Base64 Encoding:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "Welcome to LinuxCareer.com" | openssl enc -base64\nV2VsY29tZSB0byBMaW51eENhcmVlci5jb20K\n'})}),"\n",(0,t.jsx)(n.p,{children:'The output of the above command is an encrypted string containing encoded message "Welcome to LinuxCareer.com". To\ndecrypt encoded string back to its original message we need to reverse the order and attach -d option for decryption:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "V2VsY29tZSB0byBMaW51eENhcmVlci5jb20K" | openssl enc -base64 -d\nWelcome to LinuxCareer.com\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The encryption above is simple to use, however, it lacks an important feature of a password, which should be used for\nencryption. ",(0,t.jsxs)(n.em,{children:["The procedure above simply exposes the original password in another plain text in the form of of\n",(0,t.jsx)(n.strong,{children:'echo "V2VsY29tZSB0byBMaW51eENhcmVlci5jb20K" | openssl enc -base64 -d'}),', which essentially does nothing about "hiding\nsecrets" at all']}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["What will do next is, instead of decrypting using ",(0,t.jsx)(n.code,{children:"openssl enc -base64 -d"}),", decrypting with a ",(0,t.jsx)(n.strong,{children:"password"}),'. Try to\ndecrypt the following string with a password "pass":']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'echo "U2FsdGVkX181xscMhkpIA6J0qd76N/nSjjTc9NrDUC0CBSLpZQxQ2Db7ipd7kexj" | openssl enc -aes-256-cbc -d -a\n'})}),"\n",(0,t.jsx)(n.p,{children:"i.e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "U2FsdGVkX181xscMhkpIA6J0qd76N/nSjjTc9NrDUC0CBSLpZQxQ2Db7ipd7kexj" | openssl enc -aes-256-cbc -d -a\nenter aes-256-cbc decryption password: pass\nLinuxCareer.com\n'})}),"\n",(0,t.jsx)(n.p,{children:'We see that the original message "LinuxCareer.com" got decrypted with the password "pass". To create an encrypted\nmessage with a password as the one above we can use the following linux command:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'echo "LinuxCareer.com" | openssl enc -aes-256-cbc -a\n'})}),"\n",(0,t.jsx)(n.p,{children:"i.e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "LinuxCareer.com" | openssl enc -aes-256-cbc -a\nenter aes-256-cbc encryption password:\nVerifying - enter aes-256-cbc encryption password:\nU2FsdGVkX185E3H2me2D+qmCfkEsXDTn8nCn/4sblr8=\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If we wish to store OpenSSL's output to a file instead of STDOUT simply use STDOUT redirection ",(0,t.jsx)(n.code,{children:">"}),". When storing\nencrypted output to a file we can also omit the ",(0,t.jsx)(n.code,{children:"-a"})," option as we no longer need the output to be ASCII text based:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'echo "LinuxCareer.com" | openssl enc -aes-256-cbc > openssl.dat\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "LinuxCareer.com" | openssl enc -aes-256-cbc > openssl.dat\nenter aes-256-cbc encryption password:\nVerifying - enter aes-256-cbc encryption password:\n$ file openssl.dat\nopenssl.dat: openssl enc\'d data with salted password\n'})}),"\n",(0,t.jsx)(n.p,{children:'To decrypt the "openssl.dat" file back to its original message use:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl enc -aes-256-cbc -d -in openssl.dat\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ openssl enc -aes-256-cbc -d -in openssl.dat\nenter aes-256-cbc decryption password:\nLinuxCareer.com\n"})}),"\n",(0,t.jsx)(n.h2,{id:"encrypt-and-decrypt-file",children:"Encrypt and Decrypt File"}),"\n",(0,t.jsxs)(n.p,{children:["To encrypt files with OpenSSL is as simple as encrypting messages. The only difference is that instead of the echo\ncommand we use the ",(0,t.jsx)(n.strong,{children:"-in"})," option with the actual file we would like to encrypt and ",(0,t.jsx)(n.strong,{children:"-out"})," option, which will instruct\nOpenSSL to store the encrypted file under a given name:"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f Ensure that the encrypted output file is given a different filename than the original plain input file. It is also\nrecommended to do few encrypt/decrypt test runs on dummy data before encrypting important content."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl enc -aes-256-cbc -in /etc/services -out services.dat\n"})}),"\n",(0,t.jsx)(n.p,{children:"To decrypt back our services file use:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ openssl enc -aes-256-cbc -d -in services.dat > services.txt\nenter aes-256-cbc decryption password:\n"})}),"\n",(0,t.jsx)(n.h2,{id:"encrypt-and-decrypt-directory",children:"Encrypt and Decrypt Directory"}),"\n",(0,t.jsxs)(n.p,{children:["In case that we needed to use OpenSSL to encrypt an entire directory we would, first need to create gzip ",(0,t.jsx)(n.strong,{children:"tarball"})," and\nthen encrypt the tarball with the above method or we can do both at the same time by using pipe:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ tar cz /etc | openssl enc -aes-256-cbc -out etc.tar.gz.dat\ntar: Removing leading `/' from member names\nenter aes-256-cbc encryption password:\nVerifying - enter aes-256-cbc encryption password:\n"})}),"\n",(0,t.jsx)(n.p,{children:"To decrypt and extract the entire etc/ directory to you current working directory use:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ openssl enc -aes-256-cbc -d -in etc.tar.gz.dat | tar xz\nenter aes-256-cbc decryption password:\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The method above can be quite useful for automated encrypted backups"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"using-public-and-private-keys",children:"Using Public and Private keys"}),"\n",(0,t.jsx)(n.p,{children:"In this section we will show how to encrypt and decrypt files using public and private keys. First we need to generate\nprivate and public keys. This can simply be done by:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl genrsa -out private_key.pem 1024\n"})}),"\n",(0,t.jsx)(n.p,{children:"From the private key we can then generate public key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl rsa -in private_key.pem -out public_key.pem -outform PEM -pubout\n"})}),"\n",(0,t.jsx)(n.p,{children:"At this point we should have both private and public key available in our current working directory."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ls\nprivate_key.pem  public_key.pem\n"})}),"\n",(0,t.jsx)(n.p,{children:'Next, we create some sample file called "encrypt.txt" with any arbitrary text:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ echo "Welcome to LinuxCareer.com" > encrypt.txt\n$ cat encrypt.txt\nWelcome to LinuxCareer.com\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now we are ready to encrypt this file with public key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl rsautl -encrypt -inkey public_key.pem -pubin -in encrypt.txt -out encrypt.dat\n"})}),"\n",(0,t.jsx)(n.p,{children:"i.e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ openssl rsautl -encrypt -inkey public_key.pem -pubin -in encrypt.txt -out encrypt.dat\n$ ls\nencrypt.dat  encrypt.txt  private_key.pem  public_key.pem\n$ file encrypt.dat\nencrypt.dat: openssl enc'd data with salted password\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see our new encrypt.dat file is no longer text files. To decrypt this file we need to use private key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"openssl rsautl -decrypt -inkey private_key.pem -in encrypt.dat -out new_encrypt.txt\n"})}),"\n",(0,t.jsx)(n.p,{children:"i.e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ openssl rsautl -decrypt -inkey private_key.pem -in encrypt.dat -out new_encrypt.txt\n$ cat new_encrypt.txt\nWelcome to LinuxCareer.com\n"})}),"\n",(0,t.jsx)(n.p,{children:"The syntax above is quite intuitive. As you can see we have decrypted a file encrypt.dat to its original form and save\nit as new_encrypt.txt. You can for example combine this syntax with encrypting directories example above to create\nautomated encrypted backup script."})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},5639:(e,n,s)=>{s.d(n,{Z:()=>i,a:()=>c});var t=s(1733);const a={},r=t.createContext(a);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);